#!/usr/bin/env python3
"""
Demo: AI Black Box Services for DBBasic
Shows how natural language becomes running endpoints
"""

from fastapi import FastAPI, Request, HTTPException
from typing import Dict, Any
import random
import json
from datetime import datetime

app = FastAPI(title="DBBasic AI Black Box Services")

# Simulate AI-generated services
# In production, these would be generated by LLMs from descriptions

@app.post("/ai/calculate_order_total")
async def calculate_order_total(request: Request):
    """
    AI Service: Calculate tax based on customer location
    Generated from: "Calculate tax based on customer location and add to subtotal for total"
    """
    data = await request.json()

    subtotal = data.get('subtotal', 0)
    location = data.get('customer_location', {})
    state = location.get('state', 'CA')

    # Tax rates (AI would fetch real-time rates)
    tax_rates = {
        'CA': 0.0725,
        'NY': 0.08,
        'TX': 0.0625,
        'FL': 0.06,
        'WA': 0.065
    }

    rate = tax_rates.get(state, 0.07)
    tax = subtotal * rate
    total = subtotal + tax

    return {
        'success': True,
        'service': 'calculate_order_total',
        'generated_by': 'AI from description',
        'data': {
            'subtotal': subtotal,
            'tax': round(tax, 2),
            'total': round(total, 2),
            'tax_rate': rate,
            'state': state
        }
    }

@app.post("/ai/send_order_confirmation")
async def send_order_confirmation(request: Request):
    """
    AI Service: Send order confirmation email
    Generated from: "Send a nice order confirmation email with order details and tracking link"
    """
    data = await request.json()

    customer_email = data.get('customer_email')
    order_id = data.get('order_id')
    items = data.get('items', [])

    # AI generates the email content
    tracking_number = f"TRK{random.randint(100000, 999999)}"

    email_content = f"""
    Order Confirmation #{order_id}

    Thank you for your order!

    Items:
    {chr(10).join([f"- {item.get('name', 'Item')} x{item.get('quantity', 1)}" for item in items])}

    Track your order: https://track.example.com/{tracking_number}

    We'll notify you when it ships!
    """

    return {
        'success': True,
        'service': 'send_order_confirmation',
        'generated_by': 'AI from description',
        'data': {
            'email_sent': True,
            'to': customer_email,
            'subject': f'Order #{order_id} Confirmation',
            'tracking_number': tracking_number,
            'message_id': f'msg_{random.randint(100000, 999999)}'
        }
    }

@app.post("/ai/recalculate_customer_segment")
async def recalculate_customer_segment(request: Request):
    """
    AI Service: Customer segmentation
    Generated from: "Segment customer as bronze/silver/gold/platinum based on lifetime value and order frequency"
    """
    data = await request.json()

    lifetime_value = data.get('lifetime_value', 0)
    order_count = data.get('order_count', 0)

    # AI determines segmentation logic
    if lifetime_value > 10000 or order_count > 50:
        segment = 'platinum'
        benefits = ['Free shipping', '20% discount', 'Priority support', 'Early access']
    elif lifetime_value > 5000 or order_count > 25:
        segment = 'gold'
        benefits = ['Free shipping', '15% discount', 'Priority support']
    elif lifetime_value > 1000 or order_count > 10:
        segment = 'silver'
        benefits = ['Free shipping on orders over $50', '10% discount']
    else:
        segment = 'bronze'
        benefits = ['5% discount on first order']

    return {
        'success': True,
        'service': 'recalculate_customer_segment',
        'generated_by': 'AI from description',
        'data': {
            'segment': segment,
            'benefits': benefits,
            'lifetime_value': lifetime_value,
            'order_count': order_count
        }
    }

@app.post("/ai/detect_fraud")
async def detect_fraud(request: Request):
    """
    AI Service: Fraud detection
    Generated from: "Score order for fraud risk using customer history and patterns"
    """
    data = await request.json()

    # AI analyzes patterns
    order_amount = data.get('total', 0)
    is_new_customer = data.get('is_new_customer', False)
    shipping_matches_billing = data.get('shipping_matches_billing', True)

    # AI-generated fraud scoring logic
    risk_score = 0
    reasons = []

    if order_amount > 1000:
        risk_score += 20
        reasons.append('High order amount')

    if is_new_customer:
        risk_score += 15
        reasons.append('New customer')

    if not shipping_matches_billing:
        risk_score += 25
        reasons.append('Different shipping address')

    # Random factor to simulate ML model
    risk_score += random.randint(-10, 20)
    risk_score = max(0, min(100, risk_score))

    risk_level = 'low' if risk_score < 30 else 'medium' if risk_score < 60 else 'high'

    return {
        'success': True,
        'service': 'detect_fraud',
        'generated_by': 'AI from description',
        'data': {
            'risk_score': risk_score,
            'risk_level': risk_level,
            'reasons': reasons,
            'recommend_review': risk_score > 60,
            'recommend_block': risk_score > 80
        }
    }

@app.post("/ai/optimize_prices")
async def optimize_prices(request: Request):
    """
    AI Service: Dynamic pricing
    Generated from: "Adjust prices based on competitor pricing, demand, and margin targets"
    """
    data = await request.json()

    current_price = data.get('current_price', 100)
    cost = data.get('cost', 50)
    competitor_price = data.get('competitor_price', current_price)
    demand_level = data.get('demand_level', 'normal')  # low, normal, high

    # AI determines optimal price
    margin_target = 0.3  # 30% margin
    min_price = cost * (1 + margin_target)

    # Demand multiplier
    demand_multipliers = {
        'low': 0.9,
        'normal': 1.0,
        'high': 1.1
    }

    # AI calculates optimal price
    optimal_price = competitor_price * demand_multipliers[demand_level]
    optimal_price = max(min_price, optimal_price)

    # Add some randomness to simulate market dynamics
    optimal_price *= (0.95 + random.random() * 0.1)

    return {
        'success': True,
        'service': 'optimize_prices',
        'generated_by': 'AI from description',
        'data': {
            'current_price': current_price,
            'optimal_price': round(optimal_price, 2),
            'expected_margin': round((optimal_price - cost) / optimal_price, 2),
            'price_change': round(optimal_price - current_price, 2),
            'reasoning': f'Based on {demand_level} demand and competitor at ${competitor_price}'
        }
    }

@app.get("/ai/services")
async def list_services():
    """List all AI-generated services"""
    return {
        'services': [
            {
                'name': 'calculate_order_total',
                'endpoint': '/ai/calculate_order_total',
                'description': 'Calculate tax based on customer location and add to subtotal'
            },
            {
                'name': 'send_order_confirmation',
                'endpoint': '/ai/send_order_confirmation',
                'description': 'Send order confirmation email with tracking'
            },
            {
                'name': 'recalculate_customer_segment',
                'endpoint': '/ai/recalculate_customer_segment',
                'description': 'Segment customers based on value and frequency'
            },
            {
                'name': 'detect_fraud',
                'endpoint': '/ai/detect_fraud',
                'description': 'Score orders for fraud risk'
            },
            {
                'name': 'optimize_prices',
                'endpoint': '/ai/optimize_prices',
                'description': 'Dynamic pricing optimization'
            }
        ],
        'note': 'All services auto-generated from natural language descriptions'
    }

@app.get("/")
async def root():
    return {
        'title': 'DBBasic AI Black Box Services',
        'message': 'These services were generated from natural language descriptions',
        'endpoints': [
            'GET /ai/services - List all services',
            'POST /ai/calculate_order_total - Calculate order totals',
            'POST /ai/send_order_confirmation - Send emails',
            'POST /ai/recalculate_customer_segment - Customer segmentation',
            'POST /ai/detect_fraud - Fraud detection',
            'POST /ai/optimize_prices - Price optimization'
        ],
        'philosophy': 'Config defines structure. AI implements logic. No code written.'
    }

if __name__ == "__main__":
    import uvicorn
    print("=" * 60)
    print("DBBasic AI Black Box Services")
    print("=" * 60)
    print("Services generated from natural language descriptions")
    print("No code was written - AI created these from config")
    print("-" * 60)
    print("Starting server on http://localhost:8002")
    print("-" * 60)
    uvicorn.run(app, host="0.0.0.0", port=8002)